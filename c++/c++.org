#+STARTUP: showall
#+STARTUP: lognotestate
#+TAGS:
#+SEQ_TODO: TODO STARTED DONE DEFERRED CANCELLED | WAITING DELEGATED APPT
#+DRAWERS: HIDDEN STATE
#+TITLE: C++ notes for CoP
#+CATEGORY: 
#+PROPERTY: header-args:sql             :engine postgresql  :exports both :cmdline csc370
#+PROPERTY: header-args:sqlite          :db /path/to/db  :colnames yes
#+PROPERTY: header-args:C++             :results output :flags -std=c++14 -Wall --pedantic -Werror
#+PROPERTY: header-args:R               :results output  :colnames yes
#+OPTIONS: ^:nil

* General

** Use typedefs

#+BEGIN_SRC C++
std::unordered_map<std::string,std::string> stringmap;
#+END_SRC

* Vectors

** Multi-dimensional

And allocate their size automatically

#+BEGIN_SRC C++
vector<vector<int> > A(dimension1, vector<int>(dimension2));
//or
vector<vector<int> > A(dimension1, vector<int>(dimension2),initValue);
#+END_SRC

* Collections


** Reverse a collection

#+BEGIN_SRC C++
std::reverse(v.begin(), v.end());
#+END_SRC

** Back inserter

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
#+END_SRC

** map (as in functional map)

Using a backinserter, probably the best way to do it

if it does not create the vector, then why bother? Perhaps
just use for_each instead

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
std::transform(v.begin(), v.end(), back_it, [](int x)->int {
  return -x;
});
#+END_SRC

** for_each

#+BEGIN_SRC C++
std::for_each(v.begin(), v.end(), [](int x) {
   std::cout << x ;
});
#+END_SRC


* Priority queue

** Descending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int,std::vector<int>,std::greater<int>> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

** ascending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int,std::vector<int>,std::greater<int>> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

* queue/deque

#+BEGIN_SRC  C++ :main no :flags -std=c++14 -Wall --pedantic -Werror :results output 
#include <iostream>
#include <deque>
 
int main()
{
    // Create a deque containing integers
    std::deque<int> d = {7, 5, 16, 8};
 
    // Add an integer to the beginning and end of the deque
    d.push_front(13);
    d.push_back(25);
 
    // Iterate and print values of deque
    for(int n : d) {
        std::cout << n << '\n';
    }
}
#+END_SRC

** operations

| push_back  |               |
| push_front |               |
| pop_back   |               |
| pop_front  |               |
| top        |               |
| pop        |               |
| front      | inspect front |
| back       | inspect back  |


* stack

remember, pop pops, but top inspects

#+BEGIN_SRC C++
std::stack<int>   s;
 
s.push( 2 );
s.push( 6 );
s.push( 51 );

s.pop();
s.top();
#+END_SRC

* Maps

** order/unordered

#+BEGIN_SRC 
std::map<char,int> mymap;
std::unordered_map<char,int> mymap;
#+END_SRC

** constructors

Add "pairs" in the constructor"

#+BEGIN_SRC C++
stringmap second ( {{"apple","red"},{"lemon","yellow"}} );     
#+END_SRC

** Add elements

#+BEGIN_SRC C++
second["apple"] = "red";
#+END_SRC

** traversal

each element is a pair: with first and second

#+BEGIN_SRC C++
for (auto& x: sixth) 
   std::cout << " " << x.first << ":" << x.second;
#+END_SRC

** does the map have it? so we can access it

#+BEGIN_SRC C++
if (mymap.count(x)>0)
   std::cout << "mymap has " << x << std::endl;
else
   std::cout << "mymap has no " << x << std::endl;
#+END_SRC

** find: with an iterator to it

- gets specific element 
- just use count instead, unless you want to erase it

#+BEGIN_SRC C++
std::map<char,int> mymap;
std::map<char,int>::iterator it;

it = mymap.find('b');
if (it != mymap.end())
  mymap.erase (it);
#+END_SRC

* Input

** Using scanf

#+BEGIN_SRC 
int j = scanf("%d %d\n", &n,&q);
assert(j == 3)
int j = scanf("%d %d\n", &n,&q);
assert(j == 2);
to strings by a delimiter
  
#+BEGIN_SRC C++
string st;
vector<string> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(item);
}
#+END_SRC

p** input into an integer

| std::stoi  | int       |
| std::stol  | long      |
| std::stoll | long long |


#+BEGIN_SRC C++
string st;
vector<int> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(std::stoi(st));
}
#+END_SRC

** split string by delimiter


  
  #+END_SRC

* Union find

#+BEGIN_SRC c++
#include <vector>
#include <assert.h>

std::vector<int> id {};
std::vector<int> rank {};

void init_union_find(int n)
{
    id.resize(n);
    rank.resize(n,0);
    for(int i=0;i<n;i++) {
        id.at(i) = i;
    }
}

int findSet(int i)
{
    if (id.at(i) == i)
        return i;
    else {
        id.at(i) = findSet(id.at(i));
        return id.at(i);
    }
}

bool isSameSet(int p, int q)
{
    return (findSet(p) == findSet(q));
}

void unionSet(int i, int j)
{
    if (!isSameSet(i,j)) {
        int x = findSet(i);
        int y = findSet(j);
        if (rank.at(x) > rank.at(y))
            id.at(y) = x;
        else {
            id.at(x) = y;
            if (rank.at(x) == rank.at(y))
                rank.at(y)++;
        }
    }
}
#+END_SRC
