#+STARTUP: showall
#+STARTUP: lognotestate
#+TAGS:
#+SEQ_TODO: TODO STARTED DONE DEFERRED CANCELLED | WAITING DELEGATED APPT
#+DRAWERS: HIDDEN STATE
#+TITLE: C++ notes for CoP
#+CATEGORY: 
#+PROPERTY: header-args:sql             :engine postgresql  :exports both :cmdline csc370
#+PROPERTY: header-args:sqlite          :db /path/to/db  :colnames yes
#+PROPERTY: header-args:C++             :results output :flags -std=c++14 -Wall --pedantic -Werror
#+PROPERTY: header-args:R               :results output  :colnames yes
#+OPTIONS: ^:nil

* General

** Use typedefs

#+BEGIN_SRC C++
std::unordered_map<std::string,std::string> stringmap;
#+END_SRC

* Vectors

** Multi-dimensional

And allocate their size automatically

#+BEGIN_SRC C++
vector<vector<int> > A(dimension1, vector<int>(dimension2));
//or
vector<vector<int> > A(dimension1, vector<int>(dimension2),initValue);
#+END_SRC

* Collections


** Reverse a collection

#+BEGIN_SRC C++
std::reverse(v.begin(), v.end());
#+END_SRC

** Back inserter

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
#+END_SRC

#+BEGIN_SRC C++
std::copy (bar.begin(),bar.end(),back_inserter(foo));
#+END_SRC


** map (as in functional map)

Using a backinserter, probably the best way to do it

if it does not create the vector, then why bother? Perhaps
just use for_each instead

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
std::transform(v.begin(), v.end(), back_it, [](int x)->int {
  return -x;
});
#+END_SRC

** for_each

#+BEGIN_SRC C++
std::for_each(v.begin(), v.end(), [](int x) {
   std::cout << x ;
});
#+END_SRC


* Priority queue

** Descending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

#+RESULTS:
| 9 |
| 8 |
| 7 |
| 6 |
| 5 |
| 4 |
| 3 |
| 2 |
| 1 |
| 0 |

** ascending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int,std::vector<int>,std::greater<int>> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

* queue/deque

#+BEGIN_SRC  C++ :main no :flags -std=c++14 -Wall --pedantic -Werror :results output 
#include <iostream>
#include <deque>
 
int main()
{
    // Create a deque containing integers
    std::deque<int> d = {7, 5, 16, 8};
 
    // Add an integer to the beginning and end of the deque
    d.push_front(13);
    d.push_back(25);
 
    // Iterate and print values of deque
    for(int n : d) {
        std::cout << n << '\n';
    }
}
#+END_SRC

** operations

| push_back  |               |
| push_front |               |
| pop_back   |               |
| pop_front  |               |
| top        |               |
| pop        |               |
| front      | inspect front |
| back       | inspect back  |


* stack

remember, pop pops, but top inspects

#+BEGIN_SRC C++
std::stack<int>   s;
 
s.push( 2 );
s.push( 6 );
s.push( 51 );

s.pop();
s.top();
#+END_SRC

* Maps

** order/unordered

#+BEGIN_SRC 
std::map<char,int> mymap;
std::unordered_map<char,int> mymap;
#+END_SRC

** constructors

Add "pairs" in the constructor"

#+BEGIN_SRC C++
stringmap second ( {{"apple","red"},{"lemon","yellow"}} );     
#+END_SRC

** Add elements

#+BEGIN_SRC C++
second["apple"] = "red";
#+END_SRC

** traversal

each element is a pair: with first and second

#+BEGIN_SRC C++
for (auto& x: sixth) 
   std::cout << " " << x.first << ":" << x.second;
#+END_SRC

** does the map have it? so we can access it

#+BEGIN_SRC C++
if (mymap.count(x)>0)
   std::cout << "mymap has " << x << std::endl;
else
   std::cout << "mymap has no " << x << std::endl;
#+END_SRC

** find: with an iterator to it

- gets specific element 
- just use count instead, unless you want to erase it

#+BEGIN_SRC C++
std::map<char,int> mymap;
std::map<char,int>::iterator it;

it = mymap.find('b');
if (it != mymap.end())
  mymap.erase (it);
#+END_SRC

* Input

** Using scanf

#+BEGIN_SRC 
int j = scanf("%d %d\n", &n,&q);
assert(j == 3)
int j = scanf("%d %d\n", &n,&q);
assert(j == 2);
to strings by a delimiter
  
#+BEGIN_SRC C++
string st;
vector<string> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(item);
}
#+END_SRC

p** input into an integer

| std::stoi  | int       |
| std::stol  | long      |
| std::stoll | long long |


#+BEGIN_SRC C++
string st;
vector<int> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(std::stoi(st));
}
#+END_SRC


** split string by delimiter


* Algorithms 

** Checking all digits used

#+BEGIN_SRC C++
tmp = number;
while (tmp)  {
   used |= 1 << tmp % 10 ;
   tmp = tmp / 10;
}
//if used has all bits...
f (used == (1<<10) -1)
  ...
  
#+END_SRC

** Fenwick

#+BEGIN_SRC C++
#include <iostream>
#include <vector>
#include <assert.h>


int LSOne(int i)
{
    return (i & (-i));
}

class FenwickTree {
    std::vector<int> ft;
    unsigned int size;
public:
    FenwickTree(unsigned int n) {
        ft.resize(n+1);
        size = n;
    }
    int rsq(unsigned int b) {
        assert(b > 0 && b <= size);

        int sum = 0;
        for (;b;b-=LSOne(b))
            sum+= ft[b];
        return sum;
    }
    
    int rsq(unsigned int a, unsigned int b) {
        assert(b >= a);

        return rsq(b) - (a ==1 ? 0 : rsq(a-1));
    }
    
    void adjust(unsigned int k, int v) {
        assert(k > 0 && k <= size);
        for (;k<ft.size();k+=LSOne(k))
            ft[k] += v;
    }
    
};

#+END_SRC

** Union find

#+BEGIN_SRC c++
#include <vector>
#include <assert.h>

std::vector<int> id {};
std::vector<int> rank {};

void init_union_find(int n)
{
    id.resize(n);
    rank.resize(n,0);
    for(int i=0;i<n;i++) {
        id.at(i) = i;
    }
}

int findSet(int i)
{
    if (id.at(i) == i)
        return i;
    else {
        id.at(i) = findSet(id.at(i));
        return id.at(i);
    }
}

bool isSameSet(int p, int q)
{
    return (findSet(p) == findSet(q));
}

void unionSet(int i, int j)
{
    if (!isSameSet(i,j)) {
        int x = findSet(i);
        int y = findSet(j);
        if (rank.at(x) > rank.at(y))
            id.at(y) = x;
        else {
            id.at(x) = y;
            if (rank.at(x) == rank.at(y))
                rank.at(y)++;
        }
    }
}
#+END_SRC

** Graph

#+BEGIN_SRC c++
typedef int node_type;
typedef double node_value_type;
typedef std::map<std::pair<node_type, node_type>, node_value_type> graph_type;

void print_graph(graph_type &g)
{
    for(auto e:g) {
        auto v = e.first;
        std::cout << "vertex " << v.first << "," << v.second << " value " << e.second << std::endl;
    }
}

bool bellman_ford(graph_type &g, int n, node_type source,
                  std::vector<node_type>&predecessor,
                  std::vector<node_value_type>&distance)
{

    distance.resize(n);
    predecessor.resize(n);

#define LARGE (std::numeric_limits<double>::infinity())


    for(int i=0;i<n;i++) {
        distance[i] = LARGE;
        predecessor[i] = -1;
    }

    distance[source] = 0;
    /// Step 2: relax edges repeatedly
    //for i from 1 to size(vertices)-1:
    for(int i=1; i<(int)distance.size();i++) {
        int changed = false;
        for (auto edge : g) {
            node_value_type w = edge.second;
            node_type u = edge.first.first;
            node_type v = edge.first.second;
            if (distance[u] != LARGE &&  distance[u] + w < distance[v] ) {
                distance[v] = distance[u] + w;
                predecessor[v] = u;
                changed = true;
            }
            
        }
        if (!changed)
            break;
    }

// Step 3: check for negative-weight cycles
    for (auto edge: g ) {
        node_value_type w = edge.second;
        node_type u = edge.first.first;
        node_type v = edge.first.second;

        if (distance[u] != LARGE && distance[u] + w < distance[v])
            return false;
    }
    return true;
}



void print_matrix(std::vector<std::vector<double>> &g)
{
    for(auto r:g) {
        for(auto c:r) {
            std::cout << c << " ";
        }
        std::cout << std::endl;
    }
}

// big assumtipon
// graph is created with one edge

std::vector<std::vector<double>> floyd_marshall(graph_type &g, int n)
{
    std::vector<std::vector<double>> distance(n, std::vector<double>(n, LARGE));

    for(int i=0;i<n;i++)
        for(int k=0;k<n;k++)
            distance[i][k] = LARGE;

    for (auto edge : g) {
        node_value_type w = edge.second;
        node_type u = edge.first.first;
        node_type v = edge.first.second;
        distance[u][v] = w;
    }


    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                if (distance[i][j] > distance[i][k] + distance[k][j])
                    distance[i][j] = distance[i][k] + distance[k][j];

    // detect negative cycles
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            for(int k=0;k<n;k++)
                if( distance[i][k] != LARGE && // Is there any path from i to k?
                    distance[k][j] != LARGE && // Is there any path from k to j?
                    distance[k][k] < 0)      // Is k part of a negative loop?
                    distance[i][j] = -LARGE;

    //print_matrix(distance);
    return distance;
}



#+END_SRC

* Regular expressions

#+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <regex>

std::regex rgx("((1[0-2])|(0?[1-9])):([0-5][0-9])((am)|(pm))");
std::smatch match;

if (std::regex_search(input.begin(), input.end(), match, rgx)){
        std::cout << "Match\n";

        //for (auto m : match)
        //  std::cout << "  submatch " << m << '\n';

        std::cout << "match[1] = " << match[1] << '\n';
        std::cout << "match[4] = " << match[4] << '\n';
        std::cout << "match[5] = " << match[5] << '\n';
    }
    else
        std::cout << "No match\n";
 
 #+END_SRC


* Converstions

** int string to string
std::string s = std::to_string(42);

** vector to string no separator

#+BEGIN_SRC C++
   std::string st2 = std::accumulate(v.begin(), v.end(), std::string {}, [](auto i, auto j) {
           return i+std::to_string(j);
       });
   
#+END_SRC

** vector to string with separator

#+BEGIN_SRC C++
   std::string st{};
   assert(v.size() > 0);
   std::for_each(v.begin(), v.end()-1, [&st](int i) {
           st += std::to_string(i) + " ";
       });
   st += std::to_string(v.back());
#+END_SRC

#+BEGIN_SRC C++
   std::string st{};
   assert(v.size() > 0);
   std::for_each(v.begin(), v.end()-1, [&st](int i) {
           st += std::to_string(i) + " ";
       });
   st += std::to_string(v.back());
#+END_SRC

as a template

#+BEGIN_SRC C++
template <typename T>
std::string mkString(std::vector<T> &v, std::string sep=" ")
{
   std::string st2 = std::to_string(v.at(0)) + 
      std::accumulate(v.begin()+1, v.end(), std::string {}, [&sep](auto i, auto j) {
           return i+ sep + std::to_string(j);
           });

   return st2;
}
#+END_SRC

#+BEGIN_SRC C++ :main no :flags -std=c++11 -Wall --pedantic -Werror :results output :exports both
#include <iostream>
#include <functional>
int main()
{
/*
  auto f = [](int n) -> int {
          return n <= 1 ? 1 : n * f(n - 1);
      };
*/

  std::function<int (int)> factorial = [&] (int i) { 
    return (i == 1) ? 1 : i * factorial(i - 1); 
  };

  auto fact = [&] (int i) -> int { 
    return (i == 1) ? 1 : i * fact(i - 1); 
  };

  auto f = [](int i) -> int {
      return  10*i;
     } ;
  int x = f(4); //x = 24

  std::cout << x << std::endl;
  std::cout << factorial(10) << std::endl;
  return 0;
}

#+END_SRC

#+RESULTS:

* Large numbers

in my computer long and long long are the same

| int           |          2147483647 |
| long int      | 9223372036854775807 |
| long long int | 9223372036854775807 |

Programatically with template function

#+BEGIN_SRC C++
std::numeric_limits<int>::min();
std::numeric_limits<int>::max();
#+END_SRC

* Lambdas

std::function<int (int)> factorial = [&] (int i) { 


* Some math

** xor

a xor b = c then a = b xor c


** lcm

lcm(a,b) = | a * b | /gcd(a,b)

** gcd

#+BEGIN_SRC C++
int gcd(int a, int b)
{
    if (b == 0)
        a;
    else
        gcd(b, a % b);
}
#+END_SRC

* Trees

** Tree that points to the parent

- The fenwick tree is a great data structure to keep track of the ancestors
  of a node

** Tree stored in a array


- the tree uses a vector of size n
- all elements are used
- root at 0

#+BEGIN_SRC C++
auto isInternal = [&](int i) {
    return (i < (m-1)/2);
};

std::function<void(int)> print = [&](int i) {
    assert(i < m);
    std::cout << "node " << i <<  std::endl;
    std::cout << "  value " << tree.at(i) <<  std::endl;
    
    if (isInternal(i)) {
        int off = i * 2 + 1; 
        print(off);
        print(off+1);
    }
    
};

#+END_SRC

* Arithmetic hacks

** ceiling

ceiling of x/n

#+BEGIN_SRC c++
(x + n-1)/n
#+END_SRC

floor x/n

#+BEGIN_SRC c++
x/n
#+END_SRC

* Get all the bits as a vector

#+BEGIN_SRC c++
std::vector<int> get_bits(int n) {
    int i = 0;
    std::vector<int> b;
    while (n>0) {
        int bit = n % 2;
        n = n/2;
        if (bit != 0)
            b.push_back(i);
        i++;
    }
    return b;
}

#+END_SRC
