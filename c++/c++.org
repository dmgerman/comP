#+STARTUP: showall
#+STARTUP: lognotestate
#+TAGS:
#+SEQ_TODO: TODO STARTED DONE DEFERRED CANCELLED | WAITING DELEGATED APPT
#+DRAWERS: HIDDEN STATE
#+TITLE: C++ notes for CoP
#+CATEGORY: 
#+PROPERTY: header-args:sql             :engine postgresql  :exports both :cmdline csc370
#+PROPERTY: header-args:sqlite          :db /path/to/db  :colnames yes
#+PROPERTY: header-args:C++             :results output :flags -std=c++14 -Wall --pedantic -Werror
#+PROPERTY: header-args:R               :results output  :colnames yes
#+OPTIONS: ^:nil

* General

** Use typedefs

#+BEGIN_SRC C++
std::unordered_map<std::string,std::string> stringmap;
#+END_SRC

* Vectors

** Multi-dimensional

And allocate their size automatically

#+BEGIN_SRC C++
vector<vector<int> > A(dimension1, vector<int>(dimension2));
//or
vector<vector<int> > A(dimension1, vector<int>(dimension2),initValue);
#+END_SRC

* Collections


** Reverse a collection

#+BEGIN_SRC C++
std::reverse(v.begin(), v.end());
#+END_SRC

** Back inserter

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
#+END_SRC

#+BEGIN_SRC C++
std::copy (bar.begin(),bar.end(),back_inserter(foo));
#+END_SRC


** map (as in functional map)

Using a backinserter, probably the best way to do it

if it does not create the vector, then why bother? Perhaps
just use for_each instead

#+BEGIN_SRC C++
std::back_insert_iterator< std::vector<int> > back_it (v2);
std::transform(v.begin(), v.end(), back_it, [](int x)->int {
  return -x;
});
#+END_SRC

** for_each

#+BEGIN_SRC C++
std::for_each(v.begin(), v.end(), [](int x) {
   std::cout << x ;
});
#+END_SRC


* Priority queue

** Descending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int,std::vector<int>,std::greater<int>> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

** ascending

#+BEGIN_SRC C++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

int main()
{
   std::priority_queue<int,std::vector<int>,std::greater<int>> q;
   for(int n : {1,8,5,6,3,4,0,9,7,2})
     q.push(n);
   for(int i = 0;i<10;i++) {
      std::cout << q.top() << std::endl;
      q.pop();
   }
   return 0;
}
#+END_SRC

* queue/deque

#+BEGIN_SRC  C++ :main no :flags -std=c++14 -Wall --pedantic -Werror :results output 
#include <iostream>
#include <deque>
 
int main()
{
    // Create a deque containing integers
    std::deque<int> d = {7, 5, 16, 8};
 
    // Add an integer to the beginning and end of the deque
    d.push_front(13);
    d.push_back(25);
 
    // Iterate and print values of deque
    for(int n : d) {
        std::cout << n << '\n';
    }
}
#+END_SRC

** operations

| push_back  |               |
| push_front |               |
| pop_back   |               |
| pop_front  |               |
| top        |               |
| pop        |               |
| front      | inspect front |
| back       | inspect back  |


* stack

remember, pop pops, but top inspects

#+BEGIN_SRC C++
std::stack<int>   s;
 
s.push( 2 );
s.push( 6 );
s.push( 51 );

s.pop();
s.top();
#+END_SRC

* Maps

** order/unordered

#+BEGIN_SRC 
std::map<char,int> mymap;
std::unordered_map<char,int> mymap;
#+END_SRC

** constructors

Add "pairs" in the constructor"

#+BEGIN_SRC C++
stringmap second ( {{"apple","red"},{"lemon","yellow"}} );     
#+END_SRC

** Add elements

#+BEGIN_SRC C++
second["apple"] = "red";
#+END_SRC

** traversal

each element is a pair: with first and second

#+BEGIN_SRC C++
for (auto& x: sixth) 
   std::cout << " " << x.first << ":" << x.second;
#+END_SRC

** does the map have it? so we can access it

#+BEGIN_SRC C++
if (mymap.count(x)>0)
   std::cout << "mymap has " << x << std::endl;
else
   std::cout << "mymap has no " << x << std::endl;
#+END_SRC

** find: with an iterator to it

- gets specific element 
- just use count instead, unless you want to erase it

#+BEGIN_SRC C++
std::map<char,int> mymap;
std::map<char,int>::iterator it;

it = mymap.find('b');
if (it != mymap.end())
  mymap.erase (it);
#+END_SRC

* Input

** Using scanf

#+BEGIN_SRC 
int j = scanf("%d %d\n", &n,&q);
assert(j == 3)
int j = scanf("%d %d\n", &n,&q);
assert(j == 2);
to strings by a delimiter
  
#+BEGIN_SRC C++
string st;
vector<string> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(item);
}
#+END_SRC

p** input into an integer

| std::stoi  | int       |
| std::stol  | long      |
| std::stoll | long long |


#+BEGIN_SRC C++
string st;
vector<int> tokens;
while (getline(std::cin, st, delim)) {
   tokens.push_back(std::stoi(st));
}
#+END_SRC


** split string by delimiter


* Algorithms 

** Fenwick

#+BEGIN_SRC C++
#include <iostream>
#include <vector>
#include <assert.h>


int LSOne(int i)
{
    return (i & (-i));
}

class FenwickTree {
    std::vector<int> ft;
    unsigned int size;
public:
    FenwickTree(unsigned int n) {
        ft.resize(n+1);
        size = n;
    }
    int rsq(unsigned int b) {
        assert(b > 0 && b <= size);

        int sum = 0;
        for (;b;b-=LSOne(b))
            sum+= ft[b];
        return sum;
    }
    
    int rsq(unsigned int a, unsigned int b) {
        assert(b >= a);

        return rsq(b) - (a ==1 ? 0 : rsq(a-1));
    }
    
    void adjust(unsigned int k, int v) {
        assert(k > 0 && k <= size);
        for (;k<ft.size();k+=LSOne(k))
            ft[k] += v;
    }
    
};

#+END_SRC

** Union find

#+BEGIN_SRC c++
#include <vector>
#include <assert.h>

std::vector<int> id {};
std::vector<int> rank {};

void init_union_find(int n)
{
    id.resize(n);
    rank.resize(n,0);
    for(int i=0;i<n;i++) {
        id.at(i) = i;
    }
}

int findSet(int i)
{
    if (id.at(i) == i)
        return i;
    else {
        id.at(i) = findSet(id.at(i));
        return id.at(i);
    }
}

bool isSameSet(int p, int q)
{
    return (findSet(p) == findSet(q));
}

void unionSet(int i, int j)
{
    if (!isSameSet(i,j)) {
        int x = findSet(i);
        int y = findSet(j);
        if (rank.at(x) > rank.at(y))
            id.at(y) = x;
        else {
            id.at(x) = y;
            if (rank.at(x) == rank.at(y))
                rank.at(y)++;
        }
    }
}
#+END_SRC

* Regular expressions

#+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <regex>

std::regex rgx("((1[0-2])|(0?[1-9])):([0-5][0-9])((am)|(pm))");
std::smatch match;

if (std::regex_search(input.begin(), input.end(), match, rgx)){
        std::cout << "Match\n";

        //for (auto m : match)
        //  std::cout << "  submatch " << m << '\n';

        std::cout << "match[1] = " << match[1] << '\n';
        std::cout << "match[4] = " << match[4] << '\n';
        std::cout << "match[5] = " << match[5] << '\n';
    }
    else
        std::cout << "No match\n";
 
 #+END_SRC


* Converstions

** int string to string
std::string s = std::to_string(42);

** vector to string no separator

#+BEGIN_SRC C++
   std::string st2 = std::accumulate(v.begin(), v.end(), std::string {}, [](auto i, auto j) {
           return i+std::to_string(j);
       });
   
#+END_SRC

** vector to string with separator

#+BEGIN_SRC C++
   std::string st{};
   assert(v.size() > 0);
   std::for_each(v.begin(), v.end()-1, [&st](int i) {
           st += std::to_string(i) + " ";
       });
   st += std::to_string(v.back());
#+END_SRC

#+BEGIN_SRC C++
   std::string st{};
   assert(v.size() > 0);
   std::for_each(v.begin(), v.end()-1, [&st](int i) {
           st += std::to_string(i) + " ";
       });
   st += std::to_string(v.back());
#+END_SRC

as a template

#+BEGIN_SRC C++
template <typename T>
std::string mkString(std::vector<T> &v, std::string sep=" ")
{
   std::string st2 = std::to_string(v.at(0)) + 
      std::accumulate(v.begin()+1, v.end(), std::string {}, [&sep](auto i, auto j) {
           return i+ sep + std::to_string(j);
           });

   return st2;
}
#+END_SRC

#+BEGIN_SRC C++ :main no :flags -std=c++11 -Wall --pedantic -Werror :results output :exports both
#include <iostream>
#include <functional>
int main()
{
/*
  auto f = [](int n) -> int {
          return n <= 1 ? 1 : n * f(n - 1);
      };
*/

  std::function<int (int)> factorial = [&] (int i) { 
    return (i == 1) ? 1 : i * factorial(i - 1); 
  };

  auto fact = [&] (int i) -> int { 
    return (i == 1) ? 1 : i * fact(i - 1); 
  };

  auto f = [](int i) -> int {
      return  10*i;
     } ;
  int x = f(4); //x = 24

  std::cout << x << std::endl;
  std::cout << factorial(10) << std::endl;
  return 0;
}

#+END_SRC

#+RESULTS:
